<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
               "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
<!ENTITY % local.common.attrib "xmlns:xi  CDATA  #FIXED 'http://www.w3.org/2003/XInclude'">
]>

<section id="quick-start-using-grilo">
  <section id="building-grilo">
    <title>Building Grilo from sources</title>
    <programlisting>
# Building Grilo
$ git clone git://git.gnome.org/grilo
$ cd grilo
$ ./autogen.sh --prefix=/usr
$ make
$ sudo make install

# Building Grilo Plugins
$ export PKG_CONFIG_PATH=$PWD:PKG_CONFIG_PATH
$ cd ..
$ git clone git://git.gnome.org/grilo-plugins
$ cd grilo-plugins
$ ./autogen.sh --prefix=/usr
$ make
$ sudo make install
    </programlisting>

  <para>
    You should now see the grilo libraries installed under /usr/lib and the
    plugins for grilo installed under /usr/lib/grilo-x.y, where 'x.y' represents
    the library version.
  </para>
  </section>

  <section id="testing-grilo">
    <title>Testing Grilo</title>
    <para>After building and installing grilo and grilo-plugins, do:</para>
    <programlisting>
# Execute Grilo's test GUI
$ /usr/bin/grilo-test-ui
    </programlisting>

    <para>
      This is a simple playground application that you can use to test
      the framework and its plugins.
    </para>
  </section>

  <section id="compiling-grilo-programs">
    <title>Compiling Grilo based programs</title>
    <programlisting>
gcc -o example `pkg-config --cflags --libs grilo-x.y` example.c
    </programlisting>
  </section>

  <section id="programming-with-grilo-loading-plugins">
    <title>Programming with Grilo: Loading plugins</title>
    <para>Here is a small program illustrating how you can load plugins:</para>
    <programlisting role="C">
      <xi:include  href="../../examples/loading-plugins.c"
                   parse="text"
                   xmlns:xi="http://www.w3.org/2001/XInclude"/>
    </programlisting>

    <para>
      For more information on how to operate with plugins and media
      providers (sources), please check the
      <link linkend="GrlPluginRegistry">GrlPluginRegistry</link>
      API reference.
    </para>
  </section>

  <section id="programming-with-grilo-configuring-plugins">
    <title>Programming with Grilo: Configuring plugins</title>
    <para>For some plugins to work properly, it is required that the user (or
      application developer) provides certain configuration. For example,
      some plugins may require a username and a password, others may
      require an API token to gain access to the underlying media provider.
    </para>
    <para>
      These configuration options could be mandatory (without them
      the plugin cannot operate and will fail to load), or
      optional, in which case they are intended to allow users to tweak
      certain aspects of how a particular plugin should work.
    </para>
    <para>
      An example of a mandatory configuration is in the Youtube plugin: in order
      for it to work a valid API key must be provided. It is the responsibility
      of the user (or the application developer) to get that key (usually
      registering in Youtube and applying for an application key) and provide
      it to the plugin.
    </para>
    <para>
      In order to know what confirguration options are available for a certain
      plugin, users/developers must check the plugin documentation.
    </para>
    <para>
      Here is a small program illustrating how to configure a plugin form your
      application:
    </para>
    <programlisting role="C">
      <xi:include  href="../../examples/configuring-plugins.c"
                   parse="text"
                   xmlns:xi="http://www.w3.org/2001/XInclude"/>
    </programlisting>

    <para>
      For more information on how to configure plugins
      plase check the
      <link linkend="GrlConfig">GrlConfig</link>
      API reference.
    </para>
  </section>

  <section id="programming-with-grilo-browsing">
    <title>Programming with Grilo: Browsing content</title>
    <para>Here is a small program illustrating how you can browse
      content from a particular media source (a similar approach
      can be used for searching content instead of browsing):</para>
    <programlisting role="C">
      <xi:include  href="../../examples/browsing.c"
                   parse="text"
                   xmlns:xi="http://www.w3.org/2001/XInclude"/>
    </programlisting>

    <para>
      For more information on how to operate media sources
      plase check the
      <link linkend="GrlMediaSource">GrlMediaSource</link>
      API reference.
    </para>
  </section>

  <section id="programming-with-grilo-searching">
    <title>Programming with Grilo: Searching content</title>
    <para>Here is a small program illustrating how you can search
      content by text from a particular media source (Jamendo
      in this example):</para>
    <programlisting role="C">
      <xi:include  href="../../examples/searching.c"
                   parse="text"
                   xmlns:xi="http://www.w3.org/2001/XInclude"/>
    </programlisting>

    <para>
      For more information on how to operate media sources
      plase check the
      <link linkend="GrlMediaSource">GrlMediaSource</link>
      API reference.
    </para>
  </section>

  <section id="programming-with-grilo-multivalued-data">
    <title>Programming with Grilo: Multi-valued data</title>
    <para>When working with multimedia content, it can happen that certain
      attributes of a particular media resouce are multi-valued. For example,
      a particular video resorce may have multiple URIs associated, considering
      different resolutions, streaming protocols and/or formats.
    </para>
    <para>
      Grilo provides plugin and application developers with means
      to handle multi-valued properties.
    </para>
    <para>
      One issue concerning multi-valued properties are their relations with
      other properties. Following the example of the video resource with
      multiple URIs, each of these URIs should have its own mime-type associated,
      as well as its own width and height values. When dealing with multi-valued
      properties it is necessary to make this relations among keys more explicit.
    </para>
    <para>
      Grilo provides application and plugin developers with a high-level APIs to
      handle certain relations among keys consistently. Continuing with the example
      of the video resource with multiple URIs, there is grl_media_video_add_url_data()
      and grl_media_video_get_url_data_nth() to add and retrieve all the metadata
      associated with a particular instance of the video resource (URI, mime-type,
      framerate, width and height, etc) in one go.
    </para>
    <para>
      Grilo allows plugin developers to define their own metadata keys.
      In this case, the plugin developer must also provide information
      on the relations that these keys hold with others. In this scenario
      plugin developers must use GrlRelatedKeys objects to group related keys
      together.
    </para>
    <para>
      Here is a small program illustrating how get all available URLs from
      a video resource, as well the corresponding MIME value for each one.
      We use GrlRelatedKeys instead of the high-level API from GrlMediaVideo
      to illustrate how to use it:
    </para>
    <programlisting role="C">
      <xi:include  href="../../examples/multivalues.c"
                   parse="text"
                   xmlns:xi="http://www.w3.org/2001/XInclude"/>
    </programlisting>

    <para>
      For more information on how to operate with media objects
      plase check the
      <link linkend="GrlData">GrlData</link> hierarchy
      API reference.
    </para>
  </section>

  <section id="programming-with-grilo-efficient-metadata-resolution">
    <title>Programming with Grilo: Efficient metadata resolution</title>
    <para>When executing operations that return lists of media items (like
      browse() or search()) it is convenient to ensure that we do not
      request metadata that could slow down the operation unless it
      is really necessary.
      </para>
    <para>
      A clear example of this situation is the way Youtube video
      URLs are resolved: a browse operation on Youtube can usually
      be resolved in a single HTTP query, however, if one wants to
      obtain the URLs of the videos then for each video in the result
      set another HTTP request is needed. This would slow down
      the browse operation remarkably and would spam Youtube
      with requests to obtain URLs that may not be ever needed.
      Indeed, a normal player would browse a list of videos and show
      information useful for the user to select the one he/she is
      interested in (title, duration, artist, etc), the URL is not
      interesting at this stage, it is only interesting when the user
      selected a video to play, and we would be interested only
      in that single URL and not in all the URLs of the videos
      we are displaying.
    </para>
    <para>
      Grilo provides methods to application developers to query
      the keys (if any) that may have an impact on the performance
      for a particular source (like the URL in the case of Youtube),
      but it is usually easier to just use the GRL_RESOLVE_FAST_ONLY
      flag when issuing search(), browse() or query() operations.
    </para>
    <para>
      By using this flag, Grilo will resolve only the keys
      that do not have an impact on performance. If you browse
      Youtube with this flag Grilo won't request the URL key
      to the Youtube source. However, if the source could resolve
      the URL without performance penalties, it would do so
      normally.
    </para>
    <para>
      Usually, for operations like browse() or search() that operate
      with large result sets it is recommended to use
      GRL_RESOLVE_FAST_ONLY. If you really need to get the metadata
      you requested for a specific item (for example if you want to
      play a video from Youtube you really need the URL), then
      you can safely use the metadata() operation without the
      GRL_RESOLVE_FAST_ONLY flag, wich would only operate on this
      particular item, reducing the performance penalty and providing
      a more efficient solution.
    </para>
    <para>
      The program below demonstrates how this works, it accepts as
      argument the id of the source we want to operate with, when the
      source is registered it will issue a search operation requesting
      only fast keys. When the search callback is invoked we will print
      both the title information and the URL of the first media
      that matched the search text.
    </para>
    <para>
      If we run the program using grl-jamendo as target source, we will
      see that it retrieves both the title and the URL of the media
      immediately, however, if we use grl-youtube, it won't and in order
      to obtain the URL we issue a new metadata() operation, this time
      without the GRL_RESOLVE_FAST_ONLY flag.
    </para>
    <para>
      Of course this is a very simple example, in a real application the way
      this would work is that we would request the URL in a
      browse()/search() that could return hundreds of results
      and we may or may not get the URLs depending on the source
      we are operating with, but in any case we will ensure the operation
      will run as fast as possible: the user will see the results
      of the search fast. Then, when the user selects
      a media item to be played from that result set we would check if
      we have the URL already (and we will have the URL ready if the source
      could resolve it fast) in which case we can play the media right away (no
      time penalty at all from the user point of view). If the URL could not
      be resolved because it was slow for the source (like in the case of Youtube)
      then we just have to issue a metadata() operation requesting the URL,
      but that won't be too bad because we are requesting it only
      for the item that the user selected, so from the user's perspective
      the playback will take slightly more to start but would still
      be an acceptable delay.
    </para>
    <programlisting role="C">
      <xi:include  href="../../examples/efficient-metadata-resolution.c"
                   parse="text"
                   xmlns:xi="http://www.w3.org/2001/XInclude"/>
    </programlisting>
  </section>

</section>
