<?xml version="1.0"?>
<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
               "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
<!ENTITY % local.common.attrib "xmlns:xi  CDATA  #FIXED 'http://www.w3.org/2003/XInclude'">
]>

<section>
<section id="media-source-plugins-intro">
  <title>Introduction</title>

  <para>
    Media Source plugins provide access to media content. Examples
    of Media Source plugins are the Jamendo or UPnP plugins, which
    give access to content offered by Jamendo or content available
    on UPnP servers respectively.
  </para>

  <para>
    Usually, clients interact with these plugins in various ways:
    <itemizedlist>
      <listitem>
        <emphasis>Search.</emphasis>
        Users can instruct the media provider to search for
        content that matches certain keywords. This is how people
        typically interact with services like YouTube, for example.
      </listitem>
      <listitem>
        <emphasis>Browse.</emphasis>
        Users navigate through a fixed hierarchy of
        categorized content interactively. This is how people
        typically interact with UPnP services, for example.
      </listitem>
      <listitem>
        <emphasis>Query.</emphasis>
        Some times services provide features that
        are too specific to be transported to a generic,
        cross-service API. An example of this could be certain
        search filtering options. Queries allow users to 
        interact with services using service-specific language
        that can be used to exploit these features.
      </listitem>
      <listitem>
        <emphasis>Metadata.</emphasis>
        Users can request additional information (metadata)
        for a specific media item served by a media provider through
        a previous browse, search or query operation that was configured
        to retrieve only partial metadata (typically for optimization
        purposes). Metadata operations are usually used when showing
        detailed information about specific media items.
      </listitem>
      <listitem>
        <emphasis>Store.</emphasis>
        Some media providers allow (or even require) users
        to push content to them. This is how people interact with
        Podcasts for example, they "store" the feeds they are
        interested in following first.
      </listitem>
      <listitem>
        <emphasis>Remove.</emphasis>
        The opposite to the Store operation, used to remove
        content from the source.
      </listitem>
    </itemizedlist> 
  </para>
</section>

<section id="media-source-plugins-basics">
  <title>Registering Media Source Plugins</title>
  
  <para>
    Grilo plugins must use the macro GRL_PLUGIN_REGISTER(), which defines the
    entry and exit points of the plugin (called when the plugin is loaded and
    unloaded respectively) as well as its plugin identifier (a string
    identifying the plugin).
  </para>

  <para>
    The plugin identifier will be used by clients to identify
    the plugin when interacting with the plugin registry API. See
    the <link linkend="GrlPluginRegistry">GrlPluginRegistry</link>
    API reference for more details.
  </para>

  <para>
    The plugin initialization function is mandatory.
    the plugin deinitialization function is optional.
  </para>

  <para>
    Usually the plugin initialization function will create at least one <link
    linkend="GrlMediaSource">GrlMediaSource</link> instance and register it
    using <link
    linkend="grl-plugin-registry-register-source">grl_plugin_registry_register_source()</link>.
  </para>

  <para>
    A <link linkend="GrlMediaSource">GrlMediaSource</link> instance represents a
    particular source of media. Usually each plugin would spawn just one media
    source, but some plugins may spawn multiple media sources.  For example, a
    UPnP plugin spawning one media source object for each UPnP server
    discovered.
  </para>

  <para>
    Users can query the registry for available media sources and then use the
    <link linkend="GrlMediaSource">GrlMediaSource</link> API to interact with
    them.
  </para>

  <para>
    If the plugin requires configuration this should be processed
    during the plugin initialization function, which should return
    TRUE upon successful initialization or FALSE otherwise.
  </para>

  <para>
    The parameter "configs" of the plugin initialization function provides
    available configuration information provided by the user for this plugin, if
    any. This parameter is a list of <link linkend="GrlConfig">GrlConfig</link>
    objects. Usually there would be only one <link
    linkend="GrlConfig">GrlConfig</link> object in the list, but there might be
    more in the cases of plugins spawning multiple media sources that require
    different configuration options.
  </para>

  <programlisting role="C">
    <![CDATA[
gboolean
grl_foo_plugin_init (GrlPluginRegistry *registry,
                     const GrlPluginInfo *plugin,
                     GList *configs)
{
  gchar *api_key;
  GrlConfig *config;

  config = GRL_CONFIG (configs->data);

  api_key = grl_config_get_api_key (config);
  if (!api_key) {
    GRL_INFO ("Missing API Key, cannot load plugin");
    return FALSE;
  }

  GrlFooSource *source = grl_foo_source_new (api_key);
  grl_plugin_registry_register_source (registry,
                                       plugin,
                                       GRL_MEDIA_PLUGIN (source),
                                       NULL);
  g_free (api_key);
  return TRUE;
}

GRL_PLUGIN_REGISTER (grl_foo_plugin_init, NULL, "grl-foo");
]]>
  </programlisting>

  <para>
    The next step is to implement the plugin code, for that Media Source plugins
    must extend the <link linkend="GrlMediaSource">GrlMediaSource</link> class.
  </para>

  <para>
    In typical GObject fashion, developers should use the G_DEFINE_TYPE macro,
    and then provide the class initialization function
    (grl_foo_source_class_init() in the example below) and the instance
    initialization function (grl_foo_source_init() in the example below). A
    constructor function, although not mandatory, is usually nice to have
    (grl_foo_source_new() in the example below).
  </para>

  <para>
    When creating a new <link linkend="GrlMediaSource">GrlMediaSource</link>
    instance, a few properties should be provided:
    <itemizedlist>
      <listitem>
        <emphasis>source-id:</emphasis> An identifier for the source object.
        This is not the same as the plugin identifier (remember that a plugin
        can spawn multiple media source objects). This identifier can be
        used by clients when interacting with available media sources
        through the plugin registry API. See
        the <link linkend="GrlPluginRegistry">GrlPluginRegistry</link>
        API reference for more details.
      </listitem>
      <listitem>
        <emphasis>source-name:</emphasis> A name for the source object
        (typically the name that clients would show in the user interface).
      </listitem>
      <listitem>
        <emphasis>source-desc</emphasis>: A description of the media source.
      </listitem>
    </itemizedlist>
  </para>

  <para>
    In the class initialization function the plugin developer should
    provide implementations for the operations that the plugin will
    support. Most operations are optional, but for media sources
    at least one of Search, Browse and Query are expected to be
    implemented. Store and Remove are optional. Metadata is expected
    to be implemented, just like supported_keys. Slow_keys is optional.
  </para>

  <programlisting role="C">
    <![CDATA[
/* Foo class initialization code */
static void
grl_foo_source_class_init (GrlFooSourceClass * klass)
{
  GObjectClass *gobject_class = G_OBJECT_CLASS (klass);
  GrlMediaSourceClass *source_class = GRL_MEDIA_SOURCE_CLASS (klass);
  GrlMetadataSourceClass *metadata_class = GRL_METADATA_SOURCE_CLASS (klass);

  metadata_class->supported_keys = grl_foo_source_supported_keys;
  metadata_class->slow_keys = grl_foo_source_supported_keys;

  source_class->browse = grl_foo_source_browse;
  source_class->search = grl_foo_source_search;
  source_class->query = grl_foo_source_query;
  source_class->store = grl_foo_source_store;
  source_class->remove = grl_foo_source_remove;
  source_class->metadata = grl_foo_source_metadata;
}

/* Foo instance initialization code */
static void
grl_foo_source_init (GrlFooSource *source)
{
  /* Here you would initialize 'source', which is an instance
     of this class type. */
  source->api_key = NULL;
}

/* GrlFooSource constructor */
static GrlFooSource *
grl_foo_source_new (const gchar *api_key)
{
  GrlFooSource *source;

  source = GRL_FOO_SOURCE (g_object_new (GRL_FOO_SOURCE_TYPE,
                                         "source-id", "grl-foo",
                                         "source-name", "Foo",
                                         "source-desc", "Foo media provider",
                                         NULL));
  source->api_key = g_strdup (api_key);
  return source;
}

G_DEFINE_TYPE (GrlFooSource, grl_foo_source, GRL_TYPE_MEDIA_SOURCE);
]]>
  </programlisting>
</section>

<section id="media-source-plugins-supported-keys">
  <title>Implementing Supported Keys</title>
  
  <para>
    An implementation for the "supported_keys" method is mandatory for
    the plugin to work.
  </para>

  <para>
    This method is declarative, and it only has to return a list of 
    metadata keys that the plugin supports, that is, it is a declaration
    of the metadata that the plugin can provide for the media content
    that it exposes.
  </para>

  <programlisting role="C">
    <![CDATA[
static void
grl_foo_source_class_init (GrlFooSourceClass * klass)
{
  GrlMetadataSourceClass *metadata_class = GRL_METADATA_SOURCE_CLASS (klass);
  metadata_class->supported_keys = grl_foo_source_supported_keys;
}

static const GList *
grl_foo_source_supported_keys (GrlMetadataSource *source)
{
  static GList *keys = NULL;
  if (!keys) {
    keys = grl_metadata_key_list_new (GRL_METADATA_KEY_ID,
                                      GRL_METADATA_KEY_TITLE,
                                      GRL_METADATA_KEY_URL,
                                      GRL_METADATA_KEY_THUMBNAIL,
                                      GRL_METADATA_KEY_MIME,
                                      GRL_METADATA_KEY_ARTIST,
                                      GRL_METADATA_KEY_DURATION,
                                      NULL);
  }
  return keys;
}
]]>
  </programlisting>
</section>

<section id="media-source-plugins-slow-keys">
  <title>Implementing Slow Keys</title>
  
  <para>
    Implementation of the "slow_keys" method is optional, but in some
    cases it can help to improve performance remarkably.
  </para>

  <para>
    This method is intended to provide the framework with information
    on metadata that is particularly expensive for the framework
    to retrieve. The framework (or the plugin users) can then 
    use this information to remove this metadata from their requests
    when performance is important. This is, again, a declarative
    interface providing a list of keys.
  </para>

  <para>
    If the plugin does not provide an implementation for "slow_keys"
    the framework assumes that all keys are equally expensive to
    retrieve and will not perform optimizations in any case.
  </para>

  <programlisting role="C">
    <![CDATA[
static void
grl_foo_source_class_init (GrlFooSourceClass * klass)
{
  GrlMetadataSourceClass *metadata_class = GRL_METADATA_SOURCE_CLASS (klass);
  metadata_class->slow_keys = grl_foo_source_slow_keys;
}

static const GList *
grl_foo_source_slow_keys (GrlMetadataSource *source)
{
  static GList *keys = NULL;
  if (!keys) {
    keys = grl_metadata_key_list_new (GRL_METADATA_KEY_URL,
                                      NULL);
  }
  return keys;
}
]]>
  </programlisting>
</section>

<section id="media-source-plugins-search">
  <title>Implementing Search</title>
  
  <para>
    Implementation of the "search" method is optional, but at least one
    of Search, Browse and Query are expected to be implemented.
  </para>

  <para>
    This method implements text based searches, retrieving media
    that matches the text keywords provided by the user.
  </para>

  <para>
    Typically, the way this method operates is like this:
    <itemizedlist>
      <listitem>Plugin checks the input parameters and encodes the
        search operation as expected by the service provider
        (that could be a SQL query, a HTTP request, etc)</listitem>
      <listitem>Plugin executes the search on the backend. Typically this
        involves some kind blocking operation (networking, disk access, etc)
        that should be executed asynchronously when possible.</listitem>
      <listitem>Plugin receives the results from the media provider.  For each
      result received the plugin creates a <link
      linkend="GrlMedia">GrlMedia</link> object encapsulating the metadata
      obtained for that particular match.</listitem>
      <listitem>Plugin sends the <link linkend="GrlMedia">GrlMedia</link>
      objects back to the client one by one by invoking the user provided
      callback.</listitem>
    </itemizedlist>
  </para>

  <para>
    Below you can see some source code that illustrates this process:
  </para>

  <programlisting role="C">
    <![CDATA[
/* In this example we assume a media provider that can be
   queried over http, and that provides its results in xml format */

static void
grl_foo_source_class_init (GrlFooSourceClass * klass)
{
  GrlMediaSourceClass *media_class = GRL_MEDIA_SOURCE_CLASS (klass);
  media_class->search = grl_foo_source_search;
}

static void
foo_execute_search_async_cb (gchar *xml, GrlMediaSourceSearchSpec *ss)
{
  GrlMedia *media;
  gint count;

  count = count_results (xml);

  if (count == 0) {
    /* Signal "no results" */
    ss->callback (ss->source, ss->operation_id,
                  NULL, 0, ss->user_data, NULL);
  } else {
    /* parse_next parses the next media item in the XML
       and creates a GrlMedia instance with the data extracted */
    while (media = parse_next (xml))
      ss->callback (ss->source,       /* Source emitting the data */
                    ss->operation_id, /* Operation identifier */
                    media,            /* Media that matched the query */
                    --count,          /* Remaining count */
                    ss->user_data,    /* User data for the callback */
                    NULL);            /* GError instance (if an error occurred) */
  }
}

static void
grl_foo_source_search (GrlMediaSource *source, GrlMediaSourceSearchSpec *ss)
{
  gchar *foo_http_search:
  
  foo_http_search =
    g_strdup_printf("http://media.foo.com?text=%s&offset=%d&count=%d",
                    ss->text, ss->skip, ss->count);

  /* This executes an async http query and then invokes
     foo_execute_search_async_cb with the response */
  foo_execute_search_async (foo_http_search, ss);
}
]]>
  </programlisting>

  <para>
    Please, check <link linkend="media-source-plugins-common-considerations">
      Common considerations for Search, Browse and Query implementations</link>
    for more information on how to implement Search operations properly.
  </para>

  <para>
    Examples of plugins implementing Search functionality are
    grl-jamendo, grl-youtube or grl-vimeo among others.
  </para>
</section>

<section id="media-source-plugins-browse">
  <title>Implementing Browse</title>
  
  <para>
    Implementation of the "browse" method is optional, but at least one
    of Search, Browse and Query are expected to be implemented.
  </para>

  <para>
    Browsing is an interactive process, where users navigate by exploring
    these boxes exposed by the media source in hierarchical form. The idea
    of browsing a media source is the same as browsing a file system.
  </para>

  <para>
    The signature and way of operation of the Browse operation is the same as in
    the Search operation with one difference: instead of a text parameter with
    the search keywords, it receives a <link linkend="GrlMedia">GrlMedia</link>
    object representing the container (box) the user wants to browse.
  </para>

  <para>
    For the most part, plugin developers that write Browse implementations
    should consider the same rules and guidelines explained for
    Search operations.
  </para>

  <para>
    Below you can see some source code that illustrates this process:
  </para>

  <programlisting role="C">
    <![CDATA[
/* In this example we assume a media provider that can be queried over
   http, providing results in XML format. The media provider organizes
   content according to a list of categories. */

static void
grl_foo_source_class_init (GrlFooSourceClass * klass)
{
  GrlMediaSourceClass *media_class = GRL_MEDIA_SOURCE_CLASS (klass);
  media_class->browse = grl_foo_source_browse;
}

static void
foo_execute_categories_async_cb (gchar *xml, GrlMediaSourceBrowseSpec *bs)
{
  GrlMedia *media;
  gint count;

  count = count_results (xml);

  if (count == 0) {
    /* Signal "no results" */
    bs->callback (bs->source, bs->operation_id,
                  NULL, 0, bs->user_data, NULL);
  } else {
    /* parse_next parses the next category item in the XML
       and creates a GrlMedia instance with the data extracted,
       which should be of type GrlMediaBox */
    while (media = parse_next_cat (xml))
      bs->callback (bs->source,       /* Source emitting the data */
                    bs->operation_id, /* Operation identifier */
                    media,            /* The category (box)  */
                    --count,          /* Remaining count */
                    bs->user_data,    /* User data for the callback */
                    NULL);            /* GError instance (if an error occurred) */
  }
}

static void
foo_execute_media_async_cb (gchar *xml, GrlMediaSourceBrowseSpec *os)
{
  GrlMedia *media;
  gint count;

  count = count_results (xml);

  if (count == 0) {
    /* Signal "no results" */
    bs->callback (bs->source, bs->operation_id,
                  NULL, 0, bs->user_data, NULL);
  } else {
    /* parse_next parses the next media item in the XML
       and creates a GrlMedia instance with the data extracted,
       which should be of type GrlMediaImage, GrlMediaAudio or
       GrlMediaVideo */
    while (media = parse_next_media (xml))
      os->callback (os->source,       /* Source emitting the data */
                    os->operation_id, /* Operation identifier */
                    media,            /* Media that matched the query */
                    --count,          /* Remaining count */
                    os->user_data,    /* User data for the callback */
                    NULL);            /* GError instance (if an error occurred) */
  }
}

static void
grl_foo_source_browse (GrlMediaSource *source, GrlMediaSourceBrowseSpec *bs)
{
  gchar *foo_http_browse:
  
  /* We use the names of the categories as their media identifiers */
  box_id = grl_media_get_id (bs->container);

  if (!box_id) {
    /* Browsing the root box, the result must be the list of
       categories provided by the service */
    foo_http_browse =
      g_strdup_printf("http://media.foo.com/category_list",
                      os->skip, os->count);
     /* This executes an async http query and then invokes
        foo_execute_categories_async_cb with the response */
     foo_execute_categories_async (foo_http_browse, os);
  } else {
    /* Browsing a specific category */
    foo_http_browse =
      g_strdup_printf("http://media.foo.com/content/%s?offset=%d&count=%d",
                      box_id, os->skip, os->count);
     /* This executes an async http query and then invokes
        foo_execute_browse_async_cb with the response */
     foo_execute_media_async (foo_http_browse, os);
  }
}
]]>
  </programlisting>

  <para>
    Some considerations that plugin developers should take into account:
    <itemizedlist>
      <listitem>
        In the example we are assuming that the content hierarchy only has two
        levels, the first level exposes a list of categories (each one exposed
        as a <link linkend="GrlMediaBox">GrlMediaBox</link> object so the user
        knows they can be browsed again), and then a second level with the
        contents within these categories, that we assume are all media items,
        although in real life they could very well be more <link
        linkend="GrlMediaBox">GrlMediaBox</link> objects, leading to more
        complex hierarchies.
      </listitem>
      <listitem>
        <link linkend="GrlMediaBox">GrlMediaBox</link> objects returned by a
        browse operation can be browsed by clients in future Browse operations.
      </listitem>
      <listitem>
        The input parameter that informs the plugin about the box that should be
        browsed (bs->container) is of type <link
        linkend="GrlMediaBox">GrlMediaBox</link>. The plugin developer must map
        that to something the media provider understands. Typically, when <link
        linkend="GrlMedia">GrlMedia</link> objects are returned from a plugin to
        the client, they are created so their "id" property (<link
        linkend="grl-media-set-id">grl_media_set_id()</link>) can be used for
        this purpose, identifying these media resources uniquely in the context
        of the media provider.
      </listitem>
      <listitem>
        A <link linkend="GrlMediaBox">GrlMediaBox</link> object with NULL id
        always represents the root box/category in the content hierarchy exposed
        by the plugin.
      </listitem>
    </itemizedlist>
  </para>

  <para>
    Please, check <link linkend="media-source-plugins-common-considerations">
      Common considerations for Search, Browse and Query implementations</link>
    for more information on how to implement Browse operations properly.
  </para>

  <para>
    Examples of plugins implementing browse functionality are
    grl-jamendo, grl-filesystem or grl-upnp among others.
  </para>

</section>

<section id="media-source-plugins-query">
  <title>Implementing Query</title>
  
  <para>
    Implementation of the "query" method is optional, but at least one
    of Search, Browse and Query are expected to be implemented.
  </para>

  <para>
    This method provides plugin developers with means to expose
    service-specific functionality that cannot be achieved
    through regular Browse and Search operations.
  </para>

  <para>
    This method operates just like the Search method, but the text
    parameter does not represent a list of keywords to search for,
    instead, its meaning is plugin specific and defined by the plugin
    developer. 
  </para>

  <para>
    Normally, Query implementations involve parsing and decoding this
    input string into something meaningful for the media provider
    (a specific operation with its parameters).
  </para>

  <para>
    Usually, Query implementations are intended to provide advanced
    filtering capabilities and similar features that make use of
    specific features of the service that cannot be
    exposed through more service agnostic APIs, like Search or
    Browse. For example, a plugin that provides media content
    stored in a database can implement Query to give users the 
    possibility to execute SQL queries directly, by encoding the
    SQL commands in this input string, giving a lot of flexibility
    in how they access the content stored in the database in
    exchange for writing plugin-specific code in the application.
  </para>

  <para>
    The example below shows the case of a plugin implementing
    Query to let the user specify filters directly in SQL
    format for additional flexibility.
  </para>

  <programlisting role="C">
    <![CDATA[
static void
grl_foo_source_class_init (GrlFooSourceClass * klass)
{
  GrlMediaSourceClass *media_class = GRL_MEDIA_SOURCE_CLASS (klass);
  media_class->query = grl_foo_source_query;
}

static void
grl_foo_source_query (GrlMediaSource *source, GrlMediaSourceQuerySpec *qs)
{
  const gchar *sql_filter;
  GList *results;
  GrlMedia *media;
  gint count;

  /* qs->text is expected to contain a suitable SQL filter */
  sql_query = prepare_sql_with_custom_filter (qs->text, qs->skip, qs->count);
  
  /* Execute the resulting SQL query, which incorporates
     the filter provided by the user */
  results = execute_sql (sql_query);

  /* For each result obtained, invoke the user callback as usual */
  count = g_list_length (results);

  if (count == 0) {
    /* Signal "no results" */
    qs->callback (qs->source, qs->operation_id,
                  NULL, 0, qs->user_data, NULL);
  } else {
    while (media = next_result (&results))
      qs->callback (qs->source,       /* Source emitting the data */
                    qs->operation_id, /* Operation identifier */
                    media,            /* Media that matched the query */
                    --count,          /* Remaining count */
                    qs->user_data,    /* User data for the callback */
                    NULL);            /* GError instance (if an error occurred) */
  }
}
]]>
  </programlisting>

  <para>
    Please, check <link linkend="media-source-plugins-common-considerations">
      Common considerations for Search, Browse and Query implementations</link>
    for more information on how to implement Query operations properly.
  </para>

  <para>
    Examples of plugins implementing Query are grl-jamendo,
    grl-upnp or grl-bookmarks among others.
  </para>
</section>

<section id="media-source-plugins-common-considerations">
  <title>Common considerations for Search, Browse and Query implementations</title>

  <para>
    <itemizedlist>
      <listitem>Making operations synchronous would block the client
        application while the operation is executed, so providing
        a non-blocking implementation is mostly mandatory for most practical
        purposes.</listitem>
      <listitem>
        Grilo invokes plugin operations in idle callbacks to ensure that control
        is returned to the client as soon as possible. Still, plugin developers
        are encouraged to write efficient code that avoids blocking as much as
        possible, since this good practice will make applications behave
        smoother, granting a much better user experience. Use of threads in
        plugin code is not recommended, instead, splitting the work to do in 
        chunks using the idle loop is encouraged.
      </listitem>
      <listitem>Creating <link linkend="GrlMedia">GrlMedia</link> instances is
      easy, depending on the type of media you should instantiate one of the
      <link linkend="GrlMedia">GrlMedia</link> subclasses (<link
      linkend="GrlMediaImage">GrlMediaImage</link>, <link
      linkend="GrlMediaVideo">GrlMediaVideo</link>, <link
      linkend="GrlMediaAudio">GrlMediaAudio</link> or <link
      linkend="GrlMediaBox">GrlMediaBox</link>), and then use the API to set the
      corresponding data. Check the <link linkend="GrlData">GrlData</link>
      hierarchy in the API reference for more details.
      </listitem>
      <listitem>The remaining count parameter present in the callbacks is intended
        to provide the client with an <emphasis>estimation</emphasis> of how many
        more results will come after the current one as part of the same operation.</listitem>
      <listitem>Finalization of the operation must <emphasis>always</emphasis>
        be signaled by invoking the user callback with remaining count set to 0,
        even on error conditions.
      </listitem>
      <listitem>Plugin developers must ensure that all operations
        end by invoking the user callback with the remaining count parameter
        set to 0, and that this is done only once per operation. This
        behavior is expected and must be guaranteed by the plugin developer.</listitem>
      <listitem>
        Once the user callback has been invoked with the remaining count
        parameter set to 0, the operations is considered finished and the
        plugin developer must <emphasis>never</emphasis>
        invoke the user callback again for that operation again.
      </listitem>
      <listitem>
        In case of error, the plugin developer must invoke the user
        callback like this:
        <itemizedlist>
          <listitem>Set the last parameter to a non-NULL GError instance.</listitem>
          <listitem>Set the media parameter to NULL.</listitem>
          <listitem>Set the remaining count parameter to 0.</listitem>
        </itemizedlist>
        The plugin developer is responsible for releasing the error once
        the user callback is invoked.
      </listitem>
      <listitem>It is possible to finalize the operation with a NULL
        media and remaining count set to 0 if that is convenient for the
        plugin developer.
      </listitem>
      <listitem>
        Returned <link linkend="GrlMedia">GrlMedia</link> objects are owned by
        the client and should not be freed by the plugin.
      </listitem>
      <listitem>
        The list of metadata information requested by the client is
        available in the "keys" field of the Spec structure. Typically plugin
        developers don't have to care about the list of keys requested and
        would just resolve all metadata available. The only situation in which
        the plugin developer should  check the specific list of keys requested
        is when there are keys that are particularly expensive to
        resolve, in these cases the plugin should only resolve these keys if
        the user has indeed requested that information.
      </listitem>
    </itemizedlist>
  </para>
</section>


<section id="media-source-plugins-metadata">
  <title>Implementing Metadata</title>
  
  <para>
    Implementation of the "metadata" method is not mandatory
    but would be usually expected by application developers.
  </para>

  <para>
    The purpose of the metadata method is to provide additional metadata for
    <link linkend="GrlMedia">GrlMedia</link> objects produced by the media
    source.
  </para>

  <para>
    Typically, the use case for Metadata operations is applications obtaining a
    list of <link linkend="GrlMedia">GrlMedia</link> objects by executing a
    Browse, Search or Query operation , requesting limited metadata (for
    performance reasons), and then requesting additional metadata for specific
    items selected by the user.
  </para>

  <programlisting role="C">
    <![CDATA[
static void
grl_foo_source_class_init (GrlFooSourceClass * klass)
{
  GrlMediaSourceClass *media_class = GRL_MEDIA_SOURCE_CLASS (klass);
  media_class->metadata = grl_foo_source_metadata;
}

static void
foo_media_info_cb (gchar *xml, GrlMediaSourceMetadataSpec *ms)
{
  /* This resolves metadata for keys "ms->keys" from "xml" and
     stores them in "ms->media" */
  resolve_metadata_from_xml (ms->media, ms->keys, xml);

  /* Send updated ms->media back to the user */
  ms->callback (ms->source, ms->metadata_id, ms->media, ms->user_data, NULL);
}

static void
grl_foo_source_metadata (GrlMediaSource *source, GrlMediaSourceMetadataSpec *ms)
{
  const gchar *media_id;

  media_id = grl_media_get_id (ms->media);

  foo_media_info =
    g_strdup_printf("http://media.foo.com/media-info/%s", media_id);

  /* This executes an async http query and then invokes
     foo_metadata_cb with the response */
     foo_execute_metadata_async (foo_media_info, ms);
}
]]>
  </programlisting>

  <para>
    Some considerations that plugin developers should take into account:
    <itemizedlist>
      <listitem>
        Clients invoke this method passing the <link
        linkend="GrlMedia">GrlMedia</link> object that they want to update
        (ms->media). Plugin developers should resolve the requested metadata
        (ms->keys) and store it in that <link linkend="GrlMedia">GrlMedia</link>
        object.
      </listitem>
      <listitem>
        Just like in other APIs, implementation of this method is expected
        to be asynchronous to avoid blocking the user code.
      </listitem>
    </itemizedlist>
  </para>
  
  <para>
    Examples of plugins implementing Metadata are grl-youtube,
    grl-upnp or grl-jamendo among others.
  </para>
</section>


<section id="media-source-plugins-store">
  <title>Implementing Store</title>
  
  <para>
    Implementation of the "store" method is optional.
  </para>

  <para>
    The Store method is used to push new content to the media source.
  </para>

  <programlisting role="C">
    <![CDATA[
static void
grl_foo_source_class_init (GrlFooSourceClass * klass)
{
  GrlMediaSourceClass *media_class = GRL_MEDIA_SOURCE_CLASS (klass);
  media_class->store = grl_foo_source_store;
}

static void
grl_foo_source_store (GrlMediaSource *source, GrlMediaSourceStoreSpec *ss)
{
  const gchar *title;
  const gchar *uri;
  const gchar *parent_id;
  guint row_id;

  /* We get the id of the parent container where we want
     to put the new content */
  parent_id = grl_media_get_id (GRL_MEDIA (parent));

  /* We get he metadata of the media we want to push, in this case
     only URI and Title */
  uri = grl_media_get_uri ();
  title = grl_media_get_title ();
  
  /* Push the data to the media provider (in this case a database) */
  row_id = run_sql_insert (parent_id, uri, title);

  /* Set the media id in the GrlMedia object */
  grl_media_set_id (ss->media, row_id_to_media_id (row_id));

  /* Inform the user that the operation is done (NULL error means everything
     was ok */
  ss->callback (ss->source, ss->parent, ss->media, ss->user_data, NULL);
}
]]>
  </programlisting>

  <para>
    Some considerations that plugin developers should take into account:
    <itemizedlist>
      <listitem>
        After successfully storing the media, the method should assign
        a proper media id to it before invoking the user callback.
      </listitem>
    </itemizedlist>
  </para>

  <para>
    Examples of plugins implementing Store are grl-bookmarks or
    grl-podcasts.
  </para>
</section>


<section id="media-source-plugins-remove">
  <title>Implementing Remove</title>
  
  <para>
    Implementation of the "remove" method is optional.
  </para>

  <para>
    The Remove method is used to remove content from the media source.
  </para>

  <programlisting role="C">
    <![CDATA[
static void
grl_foo_source_class_init (GrlFooSourceClass * klass)
{
  GrlMediaSourceClass *media_class = GRL_MEDIA_SOURCE_CLASS (klass);
  media_class->remove = grl_foo_source_remove;
}

static void
grl_foo_source_remove (GrlMediaSource *source, GrlMediaSourceRemoveSpec *rs)
{
  /* Remove the data from the media provider (in this case a database) */
  run_sql_delete (ss->media_id);

  /* Inform the user that the operation is done (NULL error means everything
     was ok */
  rs->callback (rs->source, rs->media, rs->user_data, NULL);  
}
]]>
  </programlisting>

  <para>
    Examples of plugins implementing Remove are grl-bookmarks or
    grl-podcasts.
  </para>
</section>

<section id="media-source-plugins-media-from-uri">
  <title>Implementing Media from URI</title>

  <para>Implementation of the "media_from_uri" method is optional.</para>

  <para>
    Some times clients have access to the URI of the media, and they want to
    retrieve metadata for it. A couple of examples where this may come in handy:
    A file system browser that needs to obtain additional metadata for a
    particular media item located in the filesystem. A browser plugin that can
    obtain additional metadata for a media item given its URL. In these cases we
    know the URI of the media, but we need to create a <link
    linkend="GrlMedia">GrlMedia</link> object representing it.
  </para>

  <para>
    Plugins that want to support URI to <link linkend="GrlMedia">GrlMedia</link>
    conversions must implement the "test_media_from_uri" and "media_from_uri"
    methods.
  </para>

  <para>
    The method "test_media_from_uri" should return TRUE if, upon inspection of
    the media URI, the plugin decides that it can convert it to a <link
    linkend="GrlMedia">GrlMedia</link> object. For example, a YouTube plugin
    would check that the URI of the media is a valid YouTube URL. This method is
    asynchronous and should not block.  If the plugin cannot decide if it can or
    cannot convert the URI to a <link linkend="GrlMedia">GrlMedia</link> object
    by inspecting the URI without doing blocking operations, it should return
    TRUE. This method is used to discard efficiently plugins that cannot resolve
    the media.
  </para>

  <para>
    The method "media_from_uri" is used to do the actual conversion from the URI
    to the <link linkend="GrlMedia">GrlMedia</link> object.
  </para>

  <programlisting role="C">
    <![CDATA[
static void
grl_foo_source_class_init (GrlFooSourceClass * klass)
{
  GrlMediaSourceClass *media_class = GRL_MEDIA_SOURCE_CLASS (klass);
  media_class->test_media_from_uri = grl_foo_source_test_media_from_uri;
  media_class->media_from_uri = grl_foo_source_media_from_uri;
}

static gboolean
grl_filesystem_test_media_from_uri (GrlMediaSource *source,
                                    const gchar *uri)
{
  if (strstr (uri, "http://media.foo.com/media-info/") == uri) {
    return TRUE;
  }
  return FALSE;
}

static void
grl_filesystem_media_from_uri (GrlMediaSource *source,
                               GrlMediaSourceMediaFromUriSpec *mfus)
{
  gchar *media_id;
  GrlMedia *media;

  media_id = get_media_id_from_uri (mfus->uri);
  media = create_media_from_id (media_id);
  mfus->callback (source, mfus->media_from_uri_id, media, mfus->user_data, NULL);
  g_free (media_id);
}
]]>
  </programlisting>

  <para>
    Some considerations that plugin developers should take into account:
    <itemizedlist>
      <listitem>
        Typically "media_from_uri" involves a blocking operation, and hence
        its implementation should be asynchronous.
      </listitem>
    </itemizedlist>

    <para>
      Examples of plugins implementing "media_from_uri" are grl-filesystem
      or grl-youtube.
    </para>
  </para>
</section>

<section id="media-source-plugins-change_notification">
  <title>Notifying changes</title>

  <para>
    Source can signal clients when available media content has been
    changed. This is an optional feature.
  </para>

  <para>
    Plugins supporting content change notification must implement
    "notify_change_start" and "notify_change_stop", which let the
    user start or stop content change notification at will.
  </para>

  <para>
    Once users have activated notifications by invoking
    "notify_change_start", media sources should communicate
    any changes detected by calling grl_media_source_notify_change_list
    with a list of the media items changed.
  </para>

  <para>
    Upon calling "notify_changes_stop" the plugin must stop
    communicating changes until "notify_changes_start" is
    called again.
  </para>

  <programlisting role="C">
    <![CDATA[
static void
grl_foo_source_class_init (GrlFooSourceClass * klass)
{
  GrlMediaSourceClass *media_class = GRL_MEDIA_SOURCE_CLASS (klass);
  media_class->notify_change_start = grl_foo_source_notify_change_start;
  media_class->notify_change_stop = grl_foo_source_notify_change_stop;
}

static void
content_changed_cb (GList *changes)
{
  GPtrArray *changed_medias;

  changed_medias = g_ptr_array_sized_new (g_list_length (changes));
  while (media = next_media_from_changes (&changes)) {
    g_ptr_array_add (changed_medias, media);
  }

  grl_media_source_notify_change_list (source,
                                       changed_medias,
                                       GRL_CONTENT_CHANGED,
                                       FALSE);
}

static gboolean
grl_foo_source_notify_change_start (GrlMediaSource *source,
                                    GError **error)
{
  GrlFooMediaSource *foo_source;

  /* Listen to changes in the media content provider */
  foo_source = GRL_FOO_MEDIA_SOURCE (source);
  foo_source->listener_id = foo_subscribe_listener_new (content_changed_cb);

  return TRUE;
}

static gboolean
grl_foo_source_notify_change_stop (GrlMediaSource *source,
                                   GError **error)
{
  GrlFooMediaSource *foo_source;

  /* Stop listening to changes in the media content provider */
  foo_source = GRL_FOO_MEDIA_SOURCE (source);
  foo_listener_destroy (foo_source->listener_id);

  return TRUE;
}
]]>
  </programlisting>
  
  <para>
    Please check the <link linkend="GrlMediaSource">GrlMediaSource</link> API
    reference for more details on how <link
    linkend="grl-media-source-notify-change-list">grl_media_source_notify_change_list()</link>
    should be used.
  </para>

  <para>Examples of plugins implementing change notification are
    grl-upnp and grl-tracker among others
  </para>
</section>
</section>
