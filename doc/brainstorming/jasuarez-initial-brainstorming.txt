¿Multiples valores o no?

Case principal: *Content*.
Esta clase encapsula tanto objetos media simples, como contenedores

Content == playlist

Esquema básico: tiene propiedades (titulo, mime, ...), capacidades (qué operaciones se puede realizar sobre ellos) y métodos.
Funciones básicas get/set para añadir propiedades

Content.get(<property>);
Content.set(<property>, <value>);
Content.getURI();

Las capacidades son especialmente interesantes para los contenedores.
Indican qué operaciones (que no propiedades) se pueden realizar. Al igual que las propiedades, son dinámicas: un Content del mismo tipo puede en ciertas ocasiones permitir unas operaciones y en otras no.

   ContentAudio: un fichero de audio
   ContentVideo: un fichero de video
   ContentImage: una imagen

   ContentList: lista de contenido.

      Una playlist se podría ver como un ContentList donde cada elemento es un ContentAudio/Video.
      Una playlist de radio es un ContentList, pero cada entrada es una alternativa a usar para la reproduccion.

           Interesante: una playlist de radios seria un ContentList, donde cada elemento es a su vez otro ContentList que
           contiene las alternativas para la reproducción.

   Operación básica para un ContentList: implementar un iterador (anterior, siguiente).
   ¿Cómo se implementaría un random? Un shuffling se podría hacer como
 
              ContentList cl_shuffled = cl_normal.shuffle().

   El problema es con el random. Se podría añadir al iterador un método "next_random", que devolvería aleatoriamente un nuevo elemento. Para que visualmente se sepa que elemento hay que mostrar, un ContentList podría añadir una propiedad "index" para saber qué posicion ocupa dentro de la lista. Podría resultar necesario que el usuario especificase que quiere dicha propiedad (ver más abajo el tema de añadir propiedades en cadena).


   Cada ContentAudio/Video/Image puede añadir métodos propios que solo tienen interés para ese objeto.
   ¿Es activo el objeto? Es interesante saber si el objeto es básicamente una hashtable con propiedades, o existen métodos especiales sobre ellos. Una operacion interesante podría ser transcoding: e.g. puede un ContentImage[png] tener una operación para devolver otro ContentImage[jpg]? O es más bien una operación del source?
   En principio vamos a dejarlo como una hashtable con propiedades.

   El usuario puede crear sus propios tipos de Content -> un ContentList los manejaría opacamente.


      A partir de este se podría crear una lista de artistas, por ejemplo. Se devolvería un ContentList donde cada componente es un Content con la propiedad "artista" establecida (se puede considerar para empezar como un ContentNull, i.e., un content sin contenido real; simplifica mucho las cosas).
   

Punto de interes: un Content, en principio puede tener virtualmente infinidad de propiedades, algunas de las cuales incluso podría ser "costoso" calcular: artista, album, género, carátula, letra, información de la wikipedia del artista, etc. Así que cuando se pide un Content a un source, habría que definir (o incluso predefinir) qué propiedades estamos interesados.

El Source proporcionaría el contenido y tb. ciertas propiedades (¿debería el Source implementar tb. una interfaz de MetadataProvider? no estoy seguro), y luego los MetadataProviders o PropertyProviders irian "rellenando" los datos que faltan.

Una idea interesante sería que cada MetadataProvider especificase qué tipo de propiedades es capaz de proporcionar, y qué necesita para proporcionarlos (se sobreentiende qué propiedad). Por ejemplo, para proporcionar la carátula de un album un provider prodría necesitar conocer el artista y el album. Ello implica que debería haber un conjunto predefinido de propiedades que todo el mundo ya conociese. ¿Sería interesante echarle un vistazo a lo de las ontologías que se emplean en tracker? De alguna manera, trata de crear un conjunto estándar y bien definido de propiedades....

De todo esto se desprende que igual sería interesante tener un Content en capas, o cebolla. Un ejemplo: El usuario está interesado en una lista de albumes y sus carátulas. Puesto que no ha especificado artista, éste es necesario resolverlo para obtener la carátula. Dos opciones: la carátula no se obtiene (porque no se conoce el artista), o bien se añade a la lista de propiedades que el usuario ha pedido.

Al final, cuando está todo calculado, dos opciones: se devuelve ese objeto con la propiedad añadida, o hay que sacarlo. Con el primer caso hay que entender que lo que el usuario especifica es una lista de las propieades en las que está interesado, no la lista que *exactamente* hay que devolver.

Con la segunda opcion, hay que "extraer" la propiedad añadida artificialmente. El tema se complica si las dependencias entre propiedades se anidan. Una solución sería pues usar un ContentLayer, que basicamente permite anidar un content dentro de otro. Así, el Content que pide el usuario se añadiría dentro de otro Content al que se le añade la propiedad "artista". Cuando se pide el valor de una propiedad en un ContentLayer, si dicha propiedad no está en ese ContentLayer se busca en el hijo. Igual cuando se añade. Al final, se desencapsula el ContentLayer y se devuelve al solicitante sin dicha propiedad. Esto resuelve un problema que había en MAFW cuando se pedia una propiedad que requería de otra que no estaba.

Otro tema relativo a la gestión de propiedades "costosas". Supongamos que las carátulas se bajan de inet. ¿Tendría que quedarse bloqueado el player porque ha solicitado 20 albumes y se están descargando las carátulas? Obviamente no.

Solucion: considerar que las propiedades rápidamente resolvibles son tipo cached.
Ejemplo: el artista sería cached. La carátula depende: si el provider sieempre coge la carátula de un directorio, sería cached (podría bajar las carátulas en background); si la baja de inet, sería uncached, e incluso podría ser una mezcla: si la tiene en la caché es "cached", mientras que si no, la baja de inet, la devuelve y la guarda en la caché. En este caso sería uncached.

Por tanto, cuando se piden las propiedades, se debería especificar si estamos interesados en todas o solo en las cached. En el caso expuesto, se pedirían todas las cached, y al devolver se comprobaría que "carátula" no se ha resuelto porque no está cached (es interesante saber esto para saber si realmente es porque está sin cachear o porque no se pudo resolver por ningún provider; tb. es importante que el gestor de providers sea inteligente como para usar providers "cached") y podría pedirlas en background.

Otro tema: que pasa con los recursos cuya propiedad no puede ser calculada hasta que pasa un evento (por ejemplo, que se reproduzca). El ejemplo es el renderer, que es capaz de devolver valores una vez que se ha empezado a reproducir.

En este aspecto, igual es interesante que existan "señales" para notificar propiedades. El usuario (o el contenido?) reciviría una señal para indicar esto. Una forma de hacerlo sería que las propiedades puedan tener triggers, de forma que cuando alguien la modifica, se notifique. Así, el renderer podría cambiar el valor de una propiedad y el usuario se daría cuenta. Esto lleva a si es interesante/complicaciones de permitir cambios en los contenidos que ya tienen un valor).

La otra opcion sería pasar del tema: al fin y al cabo, el renderer no lo gestionamos nosotros sino el cliente; podría él decidir qué hace.

   Un source devuelve siempre un content -> se simplifica el api (en teoría).
