/*
 * Copyright (C) 2010-2012 Igalia S.L.
 *
 * Contact: Iago Toral Quiroga <itoral@igalia.com>
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public License
 * as published by the Free Software Foundation; version 2.1 of
 * the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 *
 */

/**
 * SECTION:grl-metadata-source
 * @short_description: Abstract base class for metadata providers
 * @see_also: #GrlPlugin, #GrlSource, #GrlMediaSource, #GrlMedia
 *
 * GrlMetadataSource is the abstract base class needed to construct a
 * source of metadata that can be used in a Grilo application.
 *
 * The metadata sources fetch metadata from different online or local
 * databases and store them in the passed #GrlMedia.
 *
 * In opposition to #GrlMediaSource, #GrlMetadataSource does not create
 * new #GrlMedia instances, just fill them up with the metadata
 * provided by the specific #GrlMetadataSource.
 *
 * For example, #GrlLastfmAlbumartSource only provides album's covers,
 * and they will be used in the #GrlMedia generated by another
 * #GrlMediaSource plugin.
 *
 * The main method is grl_metadata_source_resolve() which will retrieve
 * a list of #GrlKeyID requested for the passed #GrlMedia.
 */

#include "grl-metadata-source.h"
#include "grl-operation.h"
#include "grl-operation-priv.h"
#include "grl-source-priv.h"
#include "grl-sync-priv.h"
#include "grl-plugin-registry.h"
#include "grl-error.h"
#include "grl-log.h"
#include "data/grl-media.h"

#include <string.h>

#define GRL_LOG_DOMAIN_DEFAULT  metadata_source_log_domain
GRL_LOG_DOMAIN(metadata_source_log_domain);

struct SourceKeyMap {
  GrlMetadataSource *source;
  GList *keys;
};

struct ResolveRelayCb {
  GrlMetadataSourceResolveCb user_callback;
  gpointer user_data;
  GrlMetadataSourceResolveSpec *spec;
};

struct SetMetadataCtlCb {
  GrlMetadataSource *source;
  GrlMedia *media;
  GrlMetadataSourceSetMetadataCb user_callback;
  gpointer user_data;
  GrlMetadataSourceSetMetadataSpec *spec;
  gint pending;
  GList *next;
  GList *failed_keys;
  GList *keymaps;
  GList *specs;
};

static GrlSupportedOps grl_metadata_source_supported_operations (GrlSource *source);

/* ================ GrlMetadataSource GObject ================ */

G_DEFINE_ABSTRACT_TYPE (GrlMetadataSource,
                        grl_metadata_source,
                        GRL_TYPE_SOURCE);

static void
grl_metadata_source_class_init (GrlMetadataSourceClass *metadata_source_class)
{
  GrlSourceClass *source_class = GRL_SOURCE_CLASS (metadata_source_class);

  source_class->supported_operations = grl_metadata_source_supported_operations;
}

static void
grl_metadata_source_init (GrlMetadataSource *source)
{
}

/* ================ Utilities ================ */

static void
free_set_metadata_ctl_cb_info (struct SetMetadataCtlCb *data)
{
  GRL_DEBUG ("free_set_metadata_ctl_cb_info");

  GList *iter;
  g_object_unref (data->source);
  g_object_unref (data->media);
  g_list_free (data->failed_keys);
  iter = data->keymaps;
  while (iter) {
    struct SourceKeyMap *map = (struct SourceKeyMap *) iter->data;
    g_object_unref (map->source);
    g_list_free (map->keys);
    g_free (map);
    iter = g_list_next (iter);
  }
  g_list_free (data->keymaps);
  while (iter) {
    g_free (iter->data);
    iter = g_list_next (iter);
  }
  iter = data->specs;

  g_free (data);
}

static void
set_metadata_ctl_cb (GrlMetadataSource *source,
		     GrlMedia *media,
		     GList *failed_keys,
		     gpointer user_data,
		     const GError *error)
{
  GRL_DEBUG ("set_metadata_ctl_cb");

  struct SetMetadataCtlCb *smctlcb;
  GError *own_error = NULL;

  smctlcb = (struct SetMetadataCtlCb *) user_data;

  if (failed_keys) {
    smctlcb->failed_keys = g_list_concat (smctlcb->failed_keys, failed_keys);
  }

  smctlcb->pending--;
  if (smctlcb->pending <= 0) {
    /* We ignore the plugin errors, instead we create an own error
       if some keys were not written */
    if (smctlcb->failed_keys) {
      own_error = g_error_new (GRL_CORE_ERROR,
			       GRL_CORE_ERROR_SET_METADATA_FAILED,
			       "Some keys could not be written");
    }
    if (smctlcb->user_callback)
      smctlcb->user_callback (smctlcb->source,
                              media,
                              smctlcb->failed_keys,
                              smctlcb->user_data,
                              own_error);
    if (own_error) {
      g_error_free (own_error);
    }
    free_set_metadata_ctl_cb_info (smctlcb);
  }
}

static void
resolve_result_relay_cb (GrlMetadataSource *source,
                         guint resolve_id,
			 GrlMedia *media,
			 gpointer user_data,
			 const GError *error)
{
  gboolean should_free_error = FALSE;
  GError *_error = (GError *) error;

  GRL_DEBUG ("resolve_result_relay_cb");

  struct ResolveRelayCb *rrc;

  rrc = (struct ResolveRelayCb *) user_data;

  if (grl_source_operation_is_cancelled (GRL_SOURCE (source),
                                         rrc->spec->resolve_id)) {
    /* if the plugin already set an error, we don't care because we're
     * cancelled */
    _error = g_error_new (GRL_CORE_ERROR, GRL_CORE_ERROR_OPERATION_CANCELLED,
                          "Operation was cancelled");
    /* yet, we should free the error we just created (if we didn't create it,
     * the plugin owns it) */
    should_free_error = TRUE;
  }

  rrc->user_callback (source, rrc->spec->resolve_id, media,
                      rrc->user_data, _error);

  if (should_free_error && _error) {
    g_error_free (_error);
  }

  grl_source_set_operation_finished (GRL_SOURCE (source), rrc->spec->resolve_id);

  g_object_unref (rrc->spec->source);
  g_object_unref (rrc->spec->media);
  g_object_unref (rrc->spec->options);
  g_list_free (rrc->spec->keys);
  g_free (rrc->spec);
  g_free (rrc);
}

static gboolean
resolve_idle (gpointer user_data)
{
  GRL_DEBUG ("resolve_idle");
  GrlMetadataSourceResolveSpec *rs =
    (GrlMetadataSourceResolveSpec *) user_data;
  GRL_METADATA_SOURCE_GET_CLASS (rs->source)->resolve (rs->source, rs);
  return FALSE;
}

static void
resolve_result_async_cb (GrlMetadataSource *source,
                         guint resolve_id,
                         GrlMedia *media,
                         gpointer user_data,
                         const GError *error)
{
  GrlDataSync *ds = (GrlDataSync *) user_data;

  GRL_DEBUG ("resolve_result_async_cb");

  if (error) {
    ds->error = g_error_copy (error);
  }

  ds->data = media;
  ds->complete = TRUE;
}

static void
set_metadata_result_async_cb (GrlMetadataSource *source,
                              GrlMedia *media,
                              GList *failed_keys,
                              gpointer user_data,
                              const GError *error)
{
  GrlDataSync *ds = (GrlDataSync *) user_data;

  GRL_DEBUG ("resolve_result_async_cb");

  if (error) {
    ds->error = g_error_copy (error);
  }

  ds->data = g_list_copy (failed_keys);
  ds->complete = TRUE;
}

static gboolean
set_metadata_idle (gpointer user_data)
{
  GRL_DEBUG ("set_metadata_idle");

  GrlMetadataSourceSetMetadataSpec *sms;
  struct SetMetadataCtlCb *smctlcb;
  struct SourceKeyMap *keymap;

  smctlcb = (struct SetMetadataCtlCb *) user_data;
  keymap = (struct SourceKeyMap *) smctlcb->next->data;

  sms = g_new0 (GrlMetadataSourceSetMetadataSpec, 1);
  sms->source = keymap->source;
  sms->keys = keymap->keys;
  sms->media = smctlcb->media;
  sms->callback = set_metadata_ctl_cb;
  sms->user_data = smctlcb;

  smctlcb->next = g_list_next (smctlcb->next);
  smctlcb->specs = g_list_prepend (smctlcb->specs, sms);

  GRL_METADATA_SOURCE_GET_CLASS (sms->source)->set_metadata (sms->source, sms);

  return (smctlcb->next != NULL);
}

static GList *
analyze_keys_to_write (GrlMetadataSource *source,
		       GList *keys,
		       GrlMetadataWritingFlags flags,
		       GList **failed_keys)
{
  GList *maps = NULL;
  struct SourceKeyMap *map;
  GrlPluginRegistry *registry;
  GList *sources = NULL;
  GList *sources_iter;

  /* 'key_list' holds keys that can be written by this source
     'unsupportedy_keys' holds those that must be handled by other sources */
  GList *key_list = g_list_copy (keys);
  GList *unsupported_keys =
    grl_source_filter_writable (GRL_SOURCE (source), &key_list, TRUE);

  if (key_list) {
    map = g_new0 (struct SourceKeyMap, 1);
    map->source = g_object_ref (source);
    map->keys = key_list;
    maps = g_list_prepend (maps, map);
  }

  if (!(flags & GRL_WRITE_FULL)) {
    /* We are only interested in using this source, we are done! */
    goto done;
  }

  if (!unsupported_keys) {
    /* All keys are writable by this source, we are done! */
    goto done;
  }

  /* Check if other sources can write the missing keys */
  registry = grl_plugin_registry_get_default ();
  sources =
    grl_plugin_registry_get_sources_by_operations (registry,
                                                   GRL_OP_SET_METADATA,
                                                   TRUE);
  for (sources_iter = sources; unsupported_keys && sources_iter;
      sources_iter = g_list_next (sources_iter)) {
    GrlMetadataSource *_source;

    _source = GRL_METADATA_SOURCE (sources_iter->data);
    if (_source == source) {
      continue;
    }

    key_list = unsupported_keys;
    unsupported_keys =
      grl_source_filter_writable (GRL_SOURCE (_source), &key_list, TRUE);
    if (!key_list) {
      continue;
    }

    map = g_new0 (struct SourceKeyMap, 1);
    map->source = g_object_ref (_source);
    map->keys = key_list;
    maps = g_list_prepend (maps, map);
  }

 done:
  *failed_keys = unsupported_keys;
  g_list_free (sources);
  return maps;
}

/* ================ API ================ */

/**
 * grl_metadata_source_may_resolve:
 * @source: a metadata source
 * @media: a media on which we want more metadata
 * @key_id: the key corresponding to a metadata we might want
 * @missing_keys: (out) (transfer full) (element-type GrlKeyID): an optional originally empty list
 *
 * Checks whether @key_id may be resolved with @source for @media, so that the
 * caller can avoid calling grl_metadata_source_resolve() if it can be known in
 * advance it will fail.
 *
 * If the resolution is known to be impossible because more keys are needed in
 * @media, and @missing_keys is not @NULL, it is populated with the list of
 * GrlKeyID that would be needed.
 *
 * This function is synchronous and should not block.
 *
 * Returns: @TRUE if there's a possibility that @source resolves @key_id for
 * @media, @FALSE otherwise.
 *
 * Since: 0.1.10
 */
gboolean
grl_metadata_source_may_resolve (GrlMetadataSource *source,
                                 GrlMedia *media,
                                 GrlKeyID key_id,
                                 GList **missing_keys)
{
  GrlMetadataSourceClass *klass;
  gboolean ret = TRUE;

  GRL_DEBUG ("grl_metadata_source_may_resolve");
  g_return_val_if_fail (GRL_IS_METADATA_SOURCE (source), FALSE);
  g_return_val_if_fail (!missing_keys || !*missing_keys, FALSE);

  klass = GRL_METADATA_SOURCE_GET_CLASS (source);

  if (klass->may_resolve) {
    return klass->may_resolve (source, media, key_id, missing_keys);
  }

  if (GRL_IS_MEDIA_SOURCE (source)) {
    /* We're more forgiving to media source, as we should only ask them keys
     * during a media source operation, and we assume they are likely to return
     * all of their supported_keys() in that case. If a media source wants to
     * behave differently, it should implement may_resolve().*/
    const GList *supported_keys = grl_source_supported_keys (GRL_SOURCE (source));
    ret = NULL != g_list_find ((GList *)supported_keys,
                               GRLKEYID_TO_POINTER (key_id));
  } else {
    GRL_WARNING ("Source %s does not implement may_resolve(), considering it "
                 "can't resolve %s",
                 grl_source_get_name (GRL_SOURCE (source)),
                 GRL_METADATA_KEY_GET_NAME (key_id));
    ret = FALSE;
  }

  return ret;
}

/**
 * grl_metadata_source_resolve:
 * @source: a metadata source
 * @keys: (element-type GrlKeyID) (allow-none): the #GList
 * of #GrlKeyID to retrieve
 * @media: Transfer object where all the metadata is stored.
 * @options: options to pass to this operation
 * @callback: (scope notified): the callback to execute when the @media metadata is filled up
 * @user_data: user data set for the @callback
 *
 * This is the main method of the #GrlMetadataSource class. It will fetch the
 * metadata of the requested keys.
 *
 * This function is asynchronous.
 *
 * Returns: the operation identifier
 *
 * Since: 0.1.14
 */
guint
grl_metadata_source_resolve (GrlMetadataSource *source,
                             const GList *keys,
                             GrlMedia *media,
                             GrlOperationOptions *options,
                             GrlMetadataSourceResolveCb callback,
                             gpointer user_data)
{
  GrlMetadataSourceResolveSpec *rs;
  GList *_keys;
  struct ResolveRelayCb *rrc;
  guint resolve_id;
  GrlMetadataResolutionFlags flags;

  GRL_DEBUG ("grl_metadata_source_resolve");

  g_return_val_if_fail (GRL_IS_METADATA_SOURCE (source), 0);
  g_return_val_if_fail (callback != NULL, 0);
  g_return_val_if_fail (media != NULL, 0);
  g_return_val_if_fail (grl_source_supported_operations (GRL_SOURCE (source)) &
                        GRL_OP_RESOLVE, 0);

  _keys = g_list_copy ((GList *) keys);

  flags = grl_operation_options_get_flags (options);

  if (flags & GRL_RESOLVE_FAST_ONLY) {
    grl_source_filter_slow (GRL_SOURCE (source), &_keys, FALSE);
  }

  resolve_id = grl_operation_generate_id ();

  /* Always hook an own relay callback so we can do some
     post-processing before handing out the results
     to the user */
  rrc = g_new0 (struct ResolveRelayCb, 1);
  rrc->user_callback = callback;
  rrc->user_data = user_data;

  rs = g_new0 (GrlMetadataSourceResolveSpec, 1);
  rs->source = g_object_ref (source);
  rs->resolve_id = resolve_id;
  rs->keys = _keys;
  rs->media = g_object_ref (media);
  rs->options = g_object_ref (options);
  rs->callback = resolve_result_relay_cb;
  rs->user_data = rrc;

  /* Save a reference to the operaton spec in the relay-cb's
     user_data so that we can free the spec there */
  rrc->spec = rs;

  grl_source_set_operation_ongoing (GRL_SOURCE (source), resolve_id);
  g_idle_add_full (flags & GRL_RESOLVE_IDLE_RELAY?
                   G_PRIORITY_DEFAULT_IDLE: G_PRIORITY_HIGH_IDLE,
                   resolve_idle,
                   rs,
                   NULL);

  return resolve_id;
}

/**
 * grl_metadata_source_resolve_sync:
 * @source: a metadata source
 * @keys: (element-type GrlKeyID) (allow-none): the #GList
 * of #GrlKeyID to retrieve
 * @media: Transfer object where all the metadata is stored
 * @options: options to pass to this operation
 * @error: a #GError, or @NULL
 *
 * This is the main method of the #GrlMetadataSource class. It will fetch the
 * metadata of the requested keys.
 *
 * This function is synchronous.
 *
 * Returns: (transfer full): the updated #GrlMedia
 *
 * Since: 0.1.6
 */
GrlMedia *
grl_metadata_source_resolve_sync (GrlMetadataSource *source,
                                  const GList *keys,
                                  GrlMedia *media,
                                  GrlOperationOptions *options,
                                  GError **error)
{
  GrlDataSync *ds;

  ds = g_slice_new0 (GrlDataSync);

  grl_metadata_source_resolve (source,
                               keys,
                               media,
                               options,
                               resolve_result_async_cb,
                               ds);

  grl_wait_for_async_operation_complete (ds);

  if (ds->error) {
    if (error) {
      *error = ds->error;
    } else {
      g_error_free (ds->error);
    }
  }

  g_slice_free (GrlDataSync, ds);

  return media;
}

/**
 * grl_metadata_source_set_metadata:
 * @source: a metadata source
 * @media: the #GrlMedia object that we want to operate on.
 * @keys: (element-type GrlKeyID) (allow-none): a list
 * of #GrlKeyID whose values we want to change.
 * @flags: Flags to configure specific behaviors of the operation.
 * @callback: (scope notified): the callback to execute when the operation is finished.
 * @user_data: user data set for the @callback
 *
 * This is the main method of the #GrlMetadataSource class. It will
 * get the values for @keys from @media and store it permanently. After
 * calling this method, future queries that return this media object
 * shall return this new values for the selected keys.
 *
 * This function is asynchronous and uses the Glib's main loop.
 *
 * Since: 0.1.4
 */
void
grl_metadata_source_set_metadata (GrlMetadataSource *source,
				  GrlMedia *media,
				  GList *keys,
				  GrlMetadataWritingFlags flags,
				  GrlMetadataSourceSetMetadataCb callback,
				  gpointer user_data)
{
  GList *keymaps;
  GList *failed_keys = NULL;
  GError *error;
  struct SetMetadataCtlCb *smctlcb;

  GRL_DEBUG ("grl_metadata_source_set_metadata");

  g_return_if_fail (GRL_IS_METADATA_SOURCE (source));
  g_return_if_fail (media != NULL);
  g_return_if_fail (keys != NULL);
  g_return_if_fail (grl_source_supported_operations (GRL_SOURCE (source)) &
                    GRL_OP_SET_METADATA);

  keymaps = analyze_keys_to_write (source, keys, flags, &failed_keys);
  if (!keymaps) {
    error = g_error_new (GRL_CORE_ERROR,
			 GRL_CORE_ERROR_SET_METADATA_FAILED,
			 "None of the specified keys is writable");
    if (callback)
      callback (source, media, failed_keys, user_data, error);
    g_error_free (error);
    g_list_free (failed_keys);
    return;
  }

  smctlcb = g_new0 (struct SetMetadataCtlCb, 1);
  smctlcb->source = g_object_ref (source);
  smctlcb->media = g_object_ref (media);
  smctlcb->user_callback = callback;
  smctlcb->user_data = user_data;
  smctlcb->keymaps = keymaps;
  smctlcb->failed_keys = failed_keys;
  smctlcb->pending = g_list_length (keymaps);
  smctlcb->next = keymaps;

  g_idle_add_full (flags & GRL_RESOLVE_IDLE_RELAY?
                   G_PRIORITY_DEFAULT_IDLE: G_PRIORITY_HIGH_IDLE,
                   set_metadata_idle,
                   smctlcb,
                   NULL);
}

/**
 * grl_metadata_source_set_metadata_sync:
 * @source: a metadata source
 * @media: the #GrlMedia object that we want to operate on
 * @keys: (element-type GrlKeyID) (allow-none): a list of
 * #GrlKeyID whose values we want to change
 * @flags: Flags to configure specific behaviors of the operation.
 * @error: a #GError, or @NULL
 *
 * This is the main method of the #GrlMetadataSource class. It will
 * get the value for @key from @media and store it permanently. After
 * calling this method, future queries that return this media object
 * shall return this new value for the selected key.
 *
 * This function is synchronous.
 *
 * Returns: (element-type GrlKeyID) (transfer container):
 * a #GList of keys that could not be updated, or @NULL
 *
 * Since: 0.1.6
 */
GList *
grl_metadata_source_set_metadata_sync (GrlMetadataSource *source,
                                       GrlMedia *media,
                                       GList *keys,
                                       GrlMetadataWritingFlags flags,
                                       GError **error)
{
  GrlDataSync *ds;
  GList *failed;

  ds = g_slice_new0 (GrlDataSync);

  grl_metadata_source_set_metadata (source,
                                    media,
                                    keys,
                                    flags,
                                    set_metadata_result_async_cb,
                                    ds);

  grl_wait_for_async_operation_complete (ds);

  if (ds->error) {
    if (error) {
      *error = ds->error;
    } else {
      g_error_free (ds->error);
    }
  }

  failed = ds->data;

  g_slice_free (GrlDataSync, ds);

  return failed;
}

static GrlSupportedOps
grl_metadata_source_supported_operations (GrlSource *source)
{
  GrlSupportedOps caps = GRL_OP_NONE;
  GrlMetadataSourceClass *metadata_source_class = GRL_METADATA_SOURCE_GET_CLASS (source);

  if (metadata_source_class->resolve)
    caps |= GRL_OP_RESOLVE;
  if (metadata_source_class->set_metadata)
    caps |= GRL_OP_SET_METADATA;
  return caps;
}
